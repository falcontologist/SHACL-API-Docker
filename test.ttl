# test.ttl
# Focused tests for SHA256 opaque-IRI inference rule
#
# Test cases:
#   Test 1 — Minimal SHA256 rule test (isolated)
#   Test 2 — Multiple senses produce different hashes
#   Test 3 — Same sense produces same hash (idempotency)
#
# Run via: POST /api/infer (send this file as body)

@prefix :     <http://example.org/ontology/> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh:   <http://www.w3.org/ns/shacl#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

# ─────────────────────────────────────────────────────────────────────────────
# SCHEMA ADDITIONS
# ─────────────────────────────────────────────────────────────────────────────

# Properties needed by the SHA256 rule
:present3sg a rdf:Property ;
    rdfs:label "present3sg"@en .

:root a rdf:Property ;
    rdfs:label "root"@en .

:sense a rdf:Property ;
    rdfs:label "sense"@en .

# Verb entry with present tense form
:acquire a :Verb ;
    rdfs:label "acquire" ;
    :present3sg "acquires" .

# ─────────────────────────────────────────────────────────────────────────────
# INFERENCE RULE (SHA256 opaque-IRI only)
# ─────────────────────────────────────────────────────────────────────────────

:Acquisition_OpaqueIRIRule a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
        sh:order 1 ;
        sh:construct """
            PREFIX :    <http://example.org/ontology/>
            PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
            CONSTRUCT {
                ?acquirer ?verbProp ?acquisition .
                ?verbProp a rdf:Property ;
                    rdfs:label      ?present3sg ;
                    rdfs:comment    ?gloss ;
                    rdfs:subPropertyOf :acquires .
            }
            WHERE {
                $this :acquirer    ?acquirer .
                $this :acquisition ?acquisition .
                $this :root        ?rootLabel .
                $this :sense       ?gloss .
                
                # Look up the verb's present tense form
                ?verb a :Verb ;
                      rdfs:label ?rootLabel ;
                      :present3sg ?present3sg .
                
                # Generate hash from root + sense
                BIND(SHA256(CONCAT(STR(?rootLabel), "|", STR(?gloss))) AS ?hash)
                BIND(IRI(CONCAT(
                    "http://example.org/ontology/",
                    STR(?present3sg), "_",
                    SUBSTR(?hash, 1, 12)
                )) AS ?verbProp)
            }
        """ ] ;
    sh:targetClass :Acquisition .

# Also need the simple :acquires property for reference
:acquires a rdf:Property ;
    rdfs:label "acquires" .

# ─────────────────────────────────────────────────────────────────────────────
# TEST 1 — Minimal SHA256 rule test
# Expected:
#   :TestBuyer1 :acquires_<hash1> :TestAsset1 .
#   :acquires_<hash1> a rdf:Property ;
#       rdfs:label "acquires" ;
#       rdfs:comment "to obtain ownership" ;
#       rdfs:subPropertyOf :acquires .
# ─────────────────────────────────────────────────────────────────────────────

[ a :Acquisition ;
    :root        "acquire" ;
    :sense       "to obtain ownership" ;
    :acquirer    :TestBuyer1 ;
    :acquisition :TestAsset1 ] .

:TestBuyer1 a :Entity ; rdfs:label "Test Buyer 1" .
:TestAsset1 a :Entity ; rdfs:label "Test Asset 1" .

# ─────────────────────────────────────────────────────────────────────────────
# TEST 2 — Multiple senses produce different hashes
# Two acquisitions with same root but different senses
# Expected:
#   :TestBuyer2a :acquires_<hashA> :TestAsset2a .
#   :TestBuyer2b :acquires_<hashB> :TestAsset2b .
#   where hashA ≠ hashB
# ─────────────────────────────────────────────────────────────────────────────

# Sense 1: ownership transfer
[ a :Acquisition ;
    :root        "acquire" ;
    :sense       "to obtain ownership" ;
    :acquirer    :TestBuyer2a ;
    :acquisition :TestAsset2a ] .

:TestBuyer2a a :Entity ; rdfs:label "Test Buyer 2a" .
:TestAsset2a a :Entity ; rdfs:label "Test Asset 2a" .

# Sense 2: learning/acquiring knowledge
[ a :Acquisition ;
    :root        "acquire" ;
    :sense       "to learn or develop a skill" ;
    :acquirer    :TestBuyer2b ;
    :acquisition :TestAsset2b ] .

:TestBuyer2b a :Entity ; rdfs:label "Test Buyer 2b" .
:TestAsset2b a :Entity ; rdfs:label "Test Asset 2b" .

# ─────────────────────────────────────────────────────────────────────────────
# TEST 3 — Same sense produces same hash (idempotency)
# Two separate acquisitions with identical root+sense
# Expected:
#   Both acquisitions produce the SAME predicate IRI
#   :acquires_<hash> (identical for both)
# ─────────────────────────────────────────────────────────────────────────────

# First instance
[ a :Acquisition ;
    :root        "acquire" ;
    :sense       "to merge or consolidate" ;
    :acquirer    :TestBuyer3a ;
    :acquisition :TestAsset3a ] .

:TestBuyer3a a :Entity ; rdfs:label "Test Buyer 3a" .
:TestAsset3a a :Entity ; rdfs:label "Test Asset 3a" .

# Second instance (same root+sense)
[ a :Acquisition ;
    :root        "acquire" ;
    :sense       "to merge or consolidate" ;
    :acquirer    :TestBuyer3b ;
    :acquisition :TestAsset3b ] .

:TestBuyer3b a :Entity ; rdfs:label "Test Buyer 3b" .
:TestAsset3b a :Entity ; rdfs:label "Test Asset 3b" .

# ─────────────────────────────────────────────────────────────────────────────
# TEST 4 — Different root words
# Test with a different verb to ensure hash varies by root
# Expected:
#   :TestBuyer4 :acquires_<hash4> :TestAsset4
#   where hash4 ≠ hashes from Test 1-3
# ─────────────────────────────────────────────────────────────────────────────

# Add another verb
:purchase a :Verb ;
    rdfs:label "purchase" ;
    :present3sg "purchases" .

[ a :Acquisition ;
    :root        "purchase" ;
    :sense       "to buy with money" ;
    :acquirer    :TestBuyer4 ;
    :acquisition :TestAsset4 ] .

:TestBuyer4 a :Entity ; rdfs:label "Test Buyer 4" .
:TestAsset4 a :Entity ; rdfs:label "Test Asset 4" .
